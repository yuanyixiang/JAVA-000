学习笔记

##### 服务器通信原理

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk1o7f538zj30wk0lk4bo.jpg" alt="image-20201025164203381" style="zoom:33%;" />

服务器通信的时候，服务器的处理分为两种类型，cpu密集型和io密集型，而我们的通信就属于io密集型，所以要充分利用cpu的资源需要多线程运行，之所以要开比核心线程数多的线程数量是因为当线程执行遇到休眠或者调用一些业务处理的时候这个线程都是无事可做的需要充分利用起来

##### 五种io模型

###### 阻塞式io、bio

执行方式是串行执行，使用accept会阻塞接收连接，可以使用多线程支持多个客户端的连接，然后进行读写操作

我的理解：读数据时inputstream之类的需要等待数据是否准备好，阻塞住，准备好了就读

###### 非阻塞io

读数据时无数据好的时候就不断轮询，不将进程投入睡眠而是返回错误。

###### io多路复用

通过select和poll轮询负责所有的socket，当某个socket有数据到达的时候就通知用户线程

elect/poll 的几大缺点:
 (1)每次调用 select，都需要把 fd 集合从用户态拷贝到

内核态，这个开销在 fd 很多时会很大

 (2)同时每次调用 select 都需要在内核遍历传递进来的

所有 fd，这个开销在 fd 很多时也很大
 (3)select 支持的文件描述符数量太小了，默认是1024

###### 信号驱动io

在用户进程需要数据的时候告诉内核要数据，用户线程可以继续执行其他的事情，数据准备好的时候会返回一个信号

###### 异步io

用户线程发送系统调用后就可以去干其他事请了，当收到信号时数据已经输入完毕。

##### Netty

Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。

Netty的传输快其实也是依赖了NIO的一个特性——*零拷贝*。我们传输的时候需要进行内核态和用户态的切换，Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。

并且写nio的会很复杂，netty进行了封装

